
<!doctype html>
<html lang="en">
<head>
  <title>Polygon Clipping - Based somewhat on F. Martinez et al. (2008)</title>
<!--
//
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
-->
  <style>
  body, html {
    background-color: #ddf;
    font-family: sans-serif;
    color: #333;
  }
  a {
    color: #33d;
    text-decoration: none;
  }
  a:hover, a:active {
    text-decoration: underline;
  }
  p {
    text-align: center;
  }
  </style>
</head>
<body onload="javascript: init();">
  <script type="module">
import { PolyBool, GeometryEpsilon } from '../dist/polybool.js';

const polybool = new PolyBool(new GeometryEpsilon());

var cnv, ctx;
var rscale = 2;
var wscale = 2;
var cnvWidth, cnvHeight;
var hover = false;
var mode = 'Intersect';
const segmentBezier = false; // how many segments? ex: 8

const dummyReceiver = {
  beginPath: () => {},
  moveTo: () => {},
  lineTo: () => {},
  bezierCurveTo: () => {},
  closePath: () => {}
};

var polyCases = [{
  name: 'Assorted Polygons',
  poly1: {
    regions: [
      [ [500,60],[500,150],[320,150],[260,210],[200,150],[200,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,150],[460,190],[460,110],[400,180],[160,90] ],
      [ [220,170],[260,30],[310,160],[310,210],[260,170],[240,190] ]
    ],
    inverted: false
  }
}, {
  name: 'Curved Leg',
  shape1: [
    [ [190,50],[530,50],[530,170],[190,170] ],
  ],
  shape2: [
    [ [330,130],[230,130,290,170,190,170],[470,170],[470,130] ],
  ]
}, {
  name: 'Open Paths',
  shape1: [
    [ [540,60],[540,180],[420,180],[420,60] ],
    [ [130,160],[350,60],[560,160] ],
  ],
  shape1Open: [1],
  shape2: [
    [ [280,60],[280,180],[150,180],[150,60] ],
    [ [130,80],[280,180,420,180,560,80] ],
  ],
  shape2Open: [1],
}, {
  name: 'Curved Shapes 1',
  poly1: {
    regions: [
      [ [450,150],[200,150,200,60,450,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,150],[380,150,380,60,500,60] ]
    ],
    inverted: false
  },
}, {
  name: 'Curved Shapes 2',
  shape1: [
    [ [410,160],[200,150,200,60,450,60] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 3',
  shape1: [
    [ [450,100],[200,150,200,60,450,60] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 4',
  shape1: [
    [ [340,150],[200,150,200,60,450,60] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 5',
  shape1: [
    [ [460,70],[200,150,200,60,450,60] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 6',
  shape1: [
    [ [450,80],[200,150,200,60,450,10] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 7',
  shape1: [
    [ [450,120],[200,150,200,60,450,60] ]
  ],
  shape2: [
    [ [500,150],[380,150,380,60,500,60] ]
  ]
}, {
  name: 'Curved Shapes 8',
  poly1: {
    regions: [
      [ [450,150],[200,150,200,60,450,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,150],[380,150,380,60,380,60] ]
    ],
    inverted: false
  },
}, {
  name: 'Curved Shapes 9',
  poly1: {
    regions: [
      [ [290,150],[200,150,200,60,270,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [290,150],[380,150,380,60,290,60] ]
    ],
    inverted: false
  },
}, {
  name: 'Curved Shapes 10',
  poly1: {
    regions: [
      [ [450,150],[200,150,200,60,450,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [510,140],[380,150,290,130,240,20] ]
    ],
    inverted: false
  },
}, {
  name: 'Curve + Line 1',
  shape1: [
    [ [600,60],[600,150],[560,190],[560,110],[500,180],[260,90] ]
  ],
  shape2: [
    [ [400,50],[400,150,200,200,200,50] ]
  ],
}, {
  name: 'Curve + Line 2',
  shape1: [
    [ [600,60],[600,150],[560,190],[560,110],[500,180],[360,110] ]
  ],
  shape2: [
    [ [400,50],[400,150,200,200,200,50] ]
  ],
}, {
  name: 'Curve + Line 3',
  shape1: [
    [ [600,60],[600,150],[560,190],[560,110],[500,180],[270,130] ]
  ],
  shape2: [
    [ [400,50],[400,150,200,200,200,50] ]
  ],
}, {
  name: 'Curve + Line 4',
  shape1: [
    [ [600,60],[600,150],[560,190],[560,110],[500,180],[240,160] ]
  ],
  shape2: [
    [ [400,50],[400,150,200,200,200,50] ]
  ],
}, {
  name: 'Curve + Line 5',
  shape1: [
    [ [600,60],[600,150],[560,190],[560,110],[500,180],[380,120] ]
  ],
  shape2: [
    [ [400,50],[400,150,200,200,200,50] ]
  ],
}, {
  name: 'Simple Rectangles',
  shape1: [
    [ [200,50],[600,50],[600,150],[200,150] ]
  ],
  shape2: [
    [ [300,150],[500,150],[500,200],[300,200] ]
  ],
}, {
  name: 'Shared Right Edge',
  poly1: {
    regions: [
      [ [500,60],[500,150],[200,150],[200,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,150],[450,230],[400,180],[590,60] ]
    ],
    inverted: false
  }
}, {
  name: 'Simple Boxes',
  poly1: {
    regions: [
      [ [500,60],[500,150],[200,150],[200,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,150],[380,150],[380,60] ]
    ],
    inverted: false
  }
}, {
  name: 'Simple Self-Overlap',
  poly1: {
    regions: [
      [ [200,50],[400,50],[400,150],[200,150] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [400,150],[500,150],[300,50],[400,50] ]
    ],
    inverted: false
  }
}, {
  name: 'M Shape',
  poly1: {
    regions: [
      [ [570,60],[570,150],[60,150],[60,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,130],[330,20],[180,130],[120,60] ]
    ],
    inverted: false
  }
}, {
  name: 'Two Triangles With Common Edge',
  poly1: {
    regions: [
      [ [620,60],[620,150],[90,150],[90,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [350,60],[480,200],[180,60] ],
      [ [180,60],[500,60],[180,220] ]
    ],
    inverted: false
  }
}, {
  name: 'Two Trianges With Common Edge, pt. 2',
  poly1: {
    regions: [
      [ [620,60],[620,150],[90,150],[90,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [400,60],[270,120],[210,60] ],
      [ [210,60],[530,60],[210,220] ]
    ],
    inverted: false
  }
}, {
  name: 'Two Triangles With Common Edge, pt. 3',
  poly1: {
    regions: [
      [ [620,60],[620,150],[90,150],[90,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [370,60],[300,220],[560,60] ],
      [ [180,60],[500,60],[180,220] ]
    ],
    inverted: false
  }
}, {
  name: 'Three Triangles',
  poly1: {
    regions: [
      [ [500,60],[500,150],[320,150] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,150],[460,190] ],
      [ [220,170],[260,30],[310,160] ],
      [ [260,210],[200,150],[200,60] ]
    ],
    inverted: false
  }
}, {
  name: 'Adjacent Edges in Status',
  poly1: {
    regions: [
      [ [620,60],[620,150],[90,150],[90,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [110,60],[420,230],[540,60] ],
      [ [180,60],[430,160],[190,200] ]
    ],
    inverted: false
  }
}, {
  name: 'Coincident Self-Intersection',
  poly1: {
    regions: [
      [ [500,60],[500,150],[320,150],[260,210],[200,150],[200,60] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [500,60],[500,150],[460,190],[460,110],[400,180],[70,90] ],
      [ [220,170],[580,130],[310,160],[310,210],[260,170],[240,190] ]
    ],
    inverted: false
  }
}, {
  name: 'Coincident Self-Intersection, pt. 2',
  poly1: {
    regions: [
      [ [100, 100], [200, 200], [300, 100] ],
      [ [200, 100], [300, 200], [400, 100] ]
    ],
    inverted: false
  },
  poly2: {
    regions: [
      [ [50, 50], [200, 50], [300, 150] ]
    ],
    inverted: false
  }
}, {
  name: 'Triple Overlap',
  poly1: {
    regions: [
      [ [500, 60], [500, 150], [320, 150], [260, 210], [200, 150], [200, 60] ]
    ],
    inverted: false
  },
  poly2: {
    regions:[
      [ [500, 60], [500, 150], [370, 60], [310, 60], [400, 180], [230, 60] ],
      [ [260, 60], [410, 60], [310, 160], [310, 210], [260, 170], [240, 190] ]
    ],
    inverted: false
  }
}];

var nextDemoIndex = -1;
var caseName, demo, polyBox;
var scaleToFit = false;
function nextDemo(d){
  nextDemoIndex = (((nextDemoIndex + d) % polyCases.length) + polyCases.length) % polyCases.length;
  demo = polyCases[nextDemoIndex];
  caseName = (nextDemoIndex + 1) + '. ' + demo.name;
  window.demo = demo;
  polyBox = { min: [false, false], max: [false, false] };
  const polyBoxPoint = (x, y) => {
    if (polyBox.min[0] === false || x < polyBox.min[0])
      polyBox.min[0] = x;
    if (polyBox.min[1] === false || y < polyBox.min[1])
      polyBox.min[1] = y;
    if (polyBox.max[0] === false || x > polyBox.max[0])
      polyBox.max[0] = x;
    if (polyBox.max[1] === false || y > polyBox.max[1])
      polyBox.max[1] = y;
  };
  const calcBox = (regions) => {
    for (const region of regions) {
      for (const pt of region) {
        for (let i = 0; i < pt.length; i += 2) {
          polyBoxPoint(pt[i], pt[i + 1]);
        }
      }
    }
  };
  if ('poly1' in demo) {
    calcBox(demo.poly1.regions);
    calcBox(demo.poly2.regions);
  } else {
    calcBox(demo.shape1);
    calcBox(demo.shape2);
  }
  recalc();
}

function setMode(txt){
  mode = txt;
  recalc();
}

function colComp(n){
  n = Math.floor(n * 256);
  if (n > 255)
    return 255;
  if (n < 0)
    return 0;
  return n;
}

function colToHex(color){
  function hex(n){
    n = colComp(n).toString(16);
    return (n.length <= 1 ? '0' : '') + n;
  }
  return '#' + hex(color[0]) + hex(color[1]) + hex(color[2]);
}

var buildLogMax = 0;
var buildLogTimer = false;
function buildLogNext(delta){
  buildLogMax += delta;
  if (buildLogMax < 0)
    buildLogMax = 0;
  if (buildLogMax > clipResult.build_log.length)
    buildLogMax = clipResult.build_log.length;
  redraw();
  return buildLogMax >= clipResult.build_log.length;
}

function buildLogNextWrap(delta){
  buildLogStop();
  if (buildLogMax <= 0 && delta < 0){
    buildLogMax = clipResult.build_log.length;
    redraw();
  }
  else if (buildLogMax >= clipResult.build_log.length && delta > 0){
    buildLogMax = 0;
    redraw();
  }
  else
    buildLogNext(delta);
}

function buildLogStop(){
  if (buildLogTimer === false)
    return;
  clearInterval(buildLogTimer);
  buildLogTimer = false;
  document.getElementById('bl_play').innerHTML = 'Play';
}

function buildLogPlay(){
  if (buildLogTimer === false){
    if (buildLogNext(1))
      buildLogMax = -1;
    buildLogTimer = setInterval(function(){
      if (buildLogNext(1)){
        buildLogStop();
        buildLogTimer = setInterval(function(){
          buildLogNextWrap(1);
          clearInterval(buildLogTimer);
        }, 100);
      }
    }, 100);
  }
  else{
    clearInterval(buildLogTimer);
    buildLogTimer = false;
  }
  document.getElementById('bl_play').innerHTML = buildLogTimer === false ? 'Play' : 'Stop';
}

class Receiver {
  regions = [];
  open = [];
  moved = false;

  beginPath() {
  }

  checkMoved() {
    if (this.moved) {
      this.regions[this.regions.length - 1].push(this.moved);
      this.moved = false;
    }
  }

  moveTo(x, y) {
    if (!this.moved) {
      this.open.push(this.regions.length);
      this.regions.push([]);
    }
    this.moved = [x, y];
  }

  lineTo(x, y) {
    this.checkMoved();
    this.regions[this.regions.length - 1].push([x, y]);
  }

  bezierCurveTo(a, b, c, d, x, y) {
    this.checkMoved();
    this.regions[this.regions.length - 1].push([a, b, c, d, x, y]);
  }

  closePath() {
    this.open.splice(
      this.open.indexOf(this.regions.length - 1),
      1
    );
  }

  done() {
    return {
      regions: this.regions,
      open: this.open,
      inverted: false,
    };
  }
}

function makeShape(regions, open) {
  const shape = polybool.shape();
  for (let i = 0; i < regions.length; i++) {
    const region = regions[i];
    shape.beginPath();
    let here = [0, 0];
    for (let i = 0; i < region.length; i++) {
      const pt = region[i];
      if (pt.length === 2) {
        if (i === 0) {
          shape.moveTo(pt[0], pt[1]);
        } else {
          shape.lineTo(pt[0], pt[1]);
        }
        here = pt;
      } else {
        if (segmentBezier === false) {
          // bezier
          shape.bezierCurveTo(pt[0], pt[1], pt[2], pt[3], pt[4], pt[5]);
        } else {
          // segmented bezier
          const seg = {
            p0: here,
            p1: [pt[0], pt[1]],
            p2: [pt[2], pt[3]],
            p3: [pt[4], pt[5]]
          };
          for (let j = 1; j <= segmentBezier; j++) {
            const s = segPoint(seg, j / segmentBezier);
            shape.lineTo(s[0], s[1]);
          }
        }
        here = [pt[4], pt[5]];
      }
    }
    if (open.indexOf(i) < 0) {
      shape.closePath();
    }
  }
  return shape;
}

var clipResult;
function recalc(){
  buildLogStop();
  buildLogMax = 0;

  if ('poly1' in demo) {
    var func = ({
      'Intersect' : (a, b) => polybool.intersect(a, b),
      'Union'     : (a, b) => polybool.union(a, b),
      'Red - Blue': (a, b) => polybool.difference(a, b),
      'Blue - Red': (a, b) => polybool.differenceRev(a, b),
      'Xor'       : (a, b) => polybool.xor(a, b)
    })[mode];
    var BL = polybool.buildLog(true);
    window.clipResult = clipResult = {
      result: func(demo.poly1, demo.poly2),
      build_log: BL
    };
  } else {
    var func = ({
      'Intersect' : (a, b) => a.combine(b).intersect().output(new Receiver()).done(),
      'Union'     : (a, b) => a.combine(b).union().output(new Receiver()).done(),
      'Red - Blue': (a, b) => a.combine(b).difference().output(new Receiver()).done(),
      'Blue - Red': (a, b) => a.combine(b).differenceRev().output(new Receiver()).done(),
      'Xor'       : (a, b) => a.combine(b).xor().output(new Receiver()).done(),
    })[mode];
    var BL = polybool.buildLog(true);
    window.clipResult = clipResult = {
      result: func(
        makeShape(demo.shape1, demo.shape1Open || []),
        makeShape(demo.shape2, demo.shape2Open || [])
      ),
      build_log: BL
    };
  }
  redraw();
}

function scaleX(x){
  if (!scaleToFit)
    return x;
  return (x - polyBox.min[0]) * 650 / (polyBox.max[0] - polyBox.min[0]) + 25;
}

function scaleY(y){
  if (!scaleToFit)
    return y;
  return (y - polyBox.min[1]) * 200 / (polyBox.max[1] - polyBox.min[1]) + 25;
}

function unscaleX(x){
  if (!scaleToFit)
    return x;
  return (x - 25) * (polyBox.max[0] - polyBox.min[0]) / 650 + polyBox.min[0];
}

function unscaleY(y){
  if (!scaleToFit)
    return y;
  return (y - 25) * (polyBox.max[1] - polyBox.min[1]) / 200 + polyBox.min[1];
}

function drawPolys(polys) {
  const mapPt = (offset) => (p, j) => (j % 2) ? scaleY(p) + offset : scaleX(p);

  function drawRegions(poly, fill) {
    for (let r = 0; r < poly.regions.length; r++) {
      const region = poly.regions[r];
      const closed = poly.open.indexOf(r) < 0;
      if (closed) {
        const lastPt = region[region.length - 1].map(mapPt(poly.offset));
        ctx.moveTo(
          lastPt[lastPt.length - 2],
          lastPt[lastPt.length - 1]
        );
      } else if (fill) {
        continue;
      }
      for (let i = 0; i < region.length; i++) {
        const pt = region[i].map(mapPt(poly.offset));
        if (!closed && i === 0) {
          ctx.moveTo(pt[0], pt[1]);
        } else if (pt.length === 2) {
          ctx.lineTo(pt[0], pt[1]);
        } else {
          ctx.bezierCurveTo(pt[0], pt[1], pt[2], pt[3], pt[4], pt[5]);
        }
      }
      if (closed) {
        ctx.closePath();
      }
    }
  }

  // fill all closed regions
  for (const poly of polys) {
    ctx.beginPath();
    if (poly.inverted){
      ctx.moveTo(poly.invertedRect[0][0], poly.invertedRect[0][1] + poly.offset);
      ctx.lineTo(poly.invertedRect[0][0], poly.invertedRect[1][1] + poly.offset);
      ctx.lineTo(poly.invertedRect[1][0], poly.invertedRect[1][1] + poly.offset);
      ctx.lineTo(poly.invertedRect[1][0], poly.invertedRect[0][1] + poly.offset);
      ctx.closePath();
    }
    drawRegions(poly, true);
    ctx.fillStyle = poly.fill;
    ctx.fill('evenodd');
  }

  // draw lines
  for (const poly of polys) {
    ctx.beginPath();
    drawRegions(poly, false);
    ctx.strokeStyle = poly.stroke;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // draw control segments
  for (const poly of polys) {
    ctx.beginPath();
    for (const region of poly.regions) {
      const lastPt = region[region.length - 1].map(mapPt(poly.offset));
      ctx.moveTo(
        lastPt[lastPt.length - 2],
        lastPt[lastPt.length - 1]
      );
      for (const pt of region) {
        const p = pt.map(mapPt(poly.offset));
        if (p.length === 6) {
          ctx.lineTo(p[0], p[1]);
          ctx.moveTo(p[2], p[3]);
          ctx.lineTo(p[4], p[5]);
        } else {
          ctx.moveTo(p[0], p[1]);
        }
      }
    }
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = poly.stroke;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  // draw verticies
  for (const poly of polys) {
    ctx.save();
    for (const region of poly.regions) {
      for (let i = 0; i < region.length; i++){
        const p = region[i];
        for (let j = 0; j < p.length; j += 2) {
          let rad = 3;
          if (hover && hover.region === region && hover.vert === i && hover.j === j) {
            rad = 6;
          }
          ctx.beginPath();
          ctx.arc(
            scaleX(p[j]),
            scaleY(p[j + 1]) + poly.offset,
            rad,
            0, Math.PI * 2
          );
          ctx.globalAlpha = j < p.length - 2 ? 0.25 : 1;
          ctx.fillStyle = poly.stroke;
          ctx.fill();
        }
      }
    }
    ctx.restore();
  }
}

function segStart(seg) {
  if ('seg' in seg) {
    return segStart(seg.seg);
  }
  return 'data' in seg ? seg.data.p0 : seg.p0;
}

function segEnd(seg) {
  if ('seg' in seg) {
    return segEnd(seg.seg);
  }
  if ('data' in seg) {
    if ('p3' in seg.data) {
      return seg.data.p3;
    }
    return seg.data.p1;
  }
  if ('p3' in seg) {
    return seg.p3;
  }
  return seg.p1;
}

function segPoint(seg, t) {
  if ('data' in seg) {
    return segPoint(seg.data, t);
  }
  if ('seg' in seg) {
    return segPoint(seg.seg, t);
  }
  if ('p3' in seg) {
    const p0 = seg.p0;
    const p1 = seg.p1;
    const p2 = seg.p2;
    const p3 = seg.p3;

    if (t === 0) {
      return p0;
    } else if (t === 1) {
      return p3;
    }

    const t1t = (1 - t) * (1 - t);
    const tt = t * t;
    const t0 = t1t * (1 - t);
    const t1 = 3 * t1t * t;
    const t2 = 3 * tt * (1 - t);
    const t3 = tt * t;

    return [
      p0[0] * t0 + p1[0] * t1 + p2[0] * t2 + p3[0] * t3,
      p0[1] * t0 + p1[1] * t1 + p2[1] * t2 + p3[1] * t3,
    ];
  } else {
    const p0 = seg.p0;
    const p1 = seg.p1;

    if (t === 0) {
      return p0;
    } else if (t === 1) {
      return p1;
    }

    return [p0[0] + (p1[0] - p0[0]) * t, p0[1] + (p1[1] - p0[1]) * t];
  }
}

function segPath(seg, ctx, skipMoveTo) {
  if ('data' in seg) {
    return segPath(seg.data, ctx, skipMoveTo);
  }
  if ('seg' in seg) {
    return segPath(seg.seg, ctx, skipMoveTo);
  }
  if (!skipMoveTo) {
    ctx.moveTo(seg.p0[0], seg.p0[1]);
  }
  if ('p3' in seg) {
    ctx.bezierCurveTo(
      seg.p1[0], seg.p1[1],
      seg.p2[0], seg.p2[1],
      seg.p3[0], seg.p3[1]
    );
  } else {
    ctx.lineTo(seg.p1[0], seg.p1[1]);
  }
}

function redraw(){
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, cnvWidth, cnvHeight);
  ctx.lineWidth = 2;

  var labels = [];

  // this is quite the mess... sorry...
  var bl_oldsegs = [];
  var bl_segs = [];
  var bl_segid = {};
  var bl_vert = 0;
  var bl_last_check = false;
  var bl_last_check_i1 = false;
  var bl_last_check_i2 = false;
  var bl_last_div_seg = false;
  var bl_last_pop_seg = false;
  var bl_last_pop_seg_i = false;
  var bl_last_status = false;
  var bl_last_temp_status = false;
  var bl_last_temp_status_i = false;
  var bl_last_chop = false;
  var bl_last_seg_keep = false;
  var bl_last_seg_keep_match = false;
  var bl_last_done = false;
  var bl_finish = false;
  var bl_status = [];
  var bl_chains_o = [];
  var bl_chainids_o = [];
  var bl_oldchains_o = [];
  var bl_oldchainids_o = [];
  var bl_chains_c = [];
  var bl_chainids_c = [];
  var bl_oldchains_c = [];
  var bl_oldchainids_c = [];
  var bl_chains_x = bl_chains_o;
  var bl_chainids_x = bl_chainids_o;
  var bl_oldchains_x = bl_oldchains_o;
  var bl_oldchainids_x = bl_oldchainids_o;
  const setChainClosed = (closed) => {
    bl_chains_x = closed ? bl_chains_c : bl_chains_o;
    bl_chainids_x = closed ? bl_chainids_c : bl_chainids_o;
    bl_oldchains_x = closed ? bl_oldchains_c : bl_oldchains_o;
    bl_oldchainids_x = closed ? bl_oldchainids_c : bl_oldchainids_o;
  };
  var bl_nextchainid = 0;
  var bl_phase = 0;
  var bl_selected = false;
  var bl_info = [];
  window.buildLogMax = buildLogMax;
  clipResult.build_log.forEach(function(blw, i){
    if (i >= buildLogMax) {
      if (i === buildLogMax) console.log(clipResult.build_log[i - 1]);
      return;
    }
    var bl = blw.data;
    bl_last_check = false;
    bl_last_div_seg = false;
    bl_last_pop_seg = false;
    bl_last_status = false;
    bl_last_chop = false;
    if (bl_last_done) {
      bl_oldsegs = [];
    }
    bl_last_done = false;
    switch (blw.type){
      case 'info':
        bl_info.unshift(blw.data);
        break;
      case 'vert':
        bl_vert = bl.x;
        break;
      case 'new_seg':
        for (var i = 0; i < bl_segs.length; i++){
          if (bl_segs[i].id === bl.seg.id){
            bl_segs.splice(i, 1);
            break;
          }
        }
        for (var i = 0; i < bl_oldsegs.length; i++){
          if (bl_oldsegs[i].id === bl.seg.id){
            bl_oldsegs.splice(i, 1);
            break;
          }
        }
        bl_segs.push(bl.seg);
        bl_segid[bl.seg.id] = {
          phase: bl_phase,
          primary: bl.primary
        };
        break;
      case 'check':
        bl_last_check = bl;
        bl_last_check_i1 = false;
        bl_last_check_i2 = false;
        for (var i = 0; i < bl_status.length; i++){
          if (bl_status[i].id === bl.seg1.id)
            bl_last_check_i1 = i;
          if (bl_status[i].id === bl.seg2.id)
            bl_last_check_i2 = i;
        }
        break;
      case 'pop_seg':
        bl_last_pop_seg = bl;
        for (var i = 0; i < bl_segs.length; i++){
          if (bl_segs[i].id === bl.seg.id){
            var r = bl_segs.splice(i, 1)[0];
            bl_oldsegs.push(r);
            break;
          }
        }
        for (var i = 0; i < bl_status.length; i++){
          if (bl_status[i].id === bl.seg.id){
            bl_last_pop_seg_i = i;
            bl_status.splice(i, 1);
            break;
          }
        }
        break;
      case 'div_seg':
        bl_last_div_seg = bl;
        break;
      case 'temp_status':
        bl_last_temp_status = bl;
        if (bl.above === false)
          bl_last_temp_status_i = -0.5;
        else{
          for (var i = 0; i < bl_status.length; i++){
            if (bl_status[i].id === bl.above.id){
              bl_last_temp_status_i = i + 0.5;
              break;
            }
          }
        }
        break;
      case 'status':
        bl_last_temp_status = false;
        bl_last_status = bl.seg.id;
        for (var i = 0; i < bl_segs.length; i++){
          if (bl_segs[i].id === bl.seg.id){
            bl_segs[i] = bl.seg;
            break;
          }
        }
        if (bl.above === false)
          bl_status.unshift(bl.seg);
        else{
          for (var i = 0; i < bl_status.length; i++){
            if (bl_status[i].id === bl.above.id){
              bl_status.splice(i + 1, 0, bl.seg);
              break;
            }
          }
        }
        break;
      case 'rewind':
        bl_last_temp_status = false;
        for (var i = 0; i < bl_segs.length; i++){
          if (bl_segs[i].id === bl.seg.id){
            bl_segs.splice(i, 1);
            break;
          }
        }
        break;
      case 'chop':
        bl_last_chop = bl;
        // fallthrough
      case 'seg_update': {
        const chk_seg = (seg) => {
          if (seg.id !== bl.seg.id)
            return seg;
          return bl.seg;
        };
        for (var i = 0; i < bl_segs.length; i++)
          bl_segs[i] = chk_seg(bl_segs[i]);
        for (var i = 0; i < bl_oldsegs.length; i++)
          bl_oldsegs[i] = chk_seg(bl_oldsegs[i]);
        break;
      }
      case 'selected':
        bl_selected = bl.segs;
        bl_phase++;
        break;
      case 'chain_start':
        bl_last_seg_keep = bl;
        bl_last_seg_keep_match = false;
        break;
      case 'chain_new':
        setChainClosed(bl.closed);
        bl_chains_x.push([bl.sf]);
        bl_chainids_x.push(bl_nextchainid++);
        bl_last_seg_keep = false;
        break;
      case 'chain_rev': {
        setChainClosed(bl.closed);
        const newChain = [];
        for (let i = 0; i < bl_chains_x[bl.index].length; i++) {
          const sf = bl_chains_x[bl.index][i];
          let seg = sf.seg;
          if ('p3' in seg) {
            seg = { p0: seg.p3, p1: seg.p2, p2: seg.p1, p3: seg.p0 };
          } else {
            seg = { p0: seg.p1, p1: seg.p0 };
          }
          newChain.unshift({ seg, fill: !sf.fill });
        }
        bl_chains_x[bl.index] = newChain;
        break;
      }
      case 'chain_add_head':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index].unshift(bl.sf);
        bl_last_seg_keep = false;
        break;
      case 'chain_add_tail':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index].push(bl.sf);
        bl_last_seg_keep = false;
        break;
      case 'chain_simp_head':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index].shift();
        bl_chains_x[bl.index][0] = bl.sf;
        break;
      case 'chain_simp_tail':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index].pop();
        bl_chains_x[bl.index][bl_chains_x[bl.index].length - 1] = bl.sf;
        break;
      case 'chain_simp_close':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index].pop();
        bl_chains_x[bl.index].shift();
        bl_chains_x[bl.index].unshift(bl.sf);
        break;
      case 'chain_simp_join':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index1].pop();
        bl_chains_x[bl.index2].shift();
        bl_chains_x[bl.index1].push(bl.sf);
        break;
      case 'chain_match':
        bl_last_seg_keep_match = { i: bl.index, c: bl.closed };
        break;
      case 'chain_con':
        bl_last_seg_keep_match = { i: bl.index1, c: bl.closed };
        break;
      case 'chain_join':
        setChainClosed(bl.closed);
        bl_chains_x[bl.index1] = bl_chains_x[bl.index1].concat(bl_chains_x[bl.index2]);
        bl_chains_x.splice(bl.index2, 1);
        bl_chainids_x.splice(bl.index2, 1);
        bl_last_seg_keep = false;
        break;
      case 'chain_close':
        setChainClosed(bl.closed);
        bl_oldchains_x.push(bl_chains_x.splice(bl.index, 1)[0]);
        bl_oldchainids_x.push(bl_chainids_x.splice(bl.index, 1)[0]);
        bl_last_seg_keep = false;
        break;
      case 'done':
        bl_last_done = true;
        bl_vert = false;
        bl_phase++;
        if (bl_phase === 5)
          bl_finish = true;
        break;
      default: console.log(blw.type, bl);
    }
  });

  function drawseg(seg, fade, size){
    var poly = bl_segid[seg.id];
    var poly1 = poly.phase === 0 || (((poly.phase === 2 && !bl_last_done) || bl_phase === 3) && poly.primary);
    if (!poly1 && bl_phase === 0)
      return;
    if (poly1 && bl_phase === 1 && !bl_last_done)
      return;
    if (bl_phase === 2 && bl_last_done && poly1)
      return;
    const m1 = segPoint(seg, 0.49);
    const m2 = segPoint(seg, 0.51);
    var ang = Math.atan2(m2[1] - m1[1], m2[0] - m1[0]);
    ctx.beginPath();
    segPath(seg, ctx);
    ctx.strokeStyle = poly1 ? (fade ? '#faa' : '#f00') : (fade ? '#aaf' : '#00f');
    ctx.lineWidth = size;
    ctx.stroke();
    function drawfill(ang, fill, mine){
      var poly1 =
        poly.phase === 0 ? mine :
        poly.phase === 1 ? !mine :
        mine === poly.primary;
      var dist = 6;
      ctx.beginPath();
      ctx.arc(
        dist * Math.cos(ang) + (m1[0] + m2[0]) / 2,
        dist * Math.sin(ang) + (m1[1] + m2[1]) / 2,
        fill === null ? 1 : 3,
        0, Math.PI * 2
      );
      ctx.fillStyle = (fill === true || fill === null) ? (poly1 ? '#f00' : '#00f') : '#fff';
      ctx.fill();
      ctx.strokeStyle = (fill === true) ? '#000' : (poly1 ? '#f00' : '#00f');
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    var d = (bl_phase <= 1 || (bl_phase === 2 && bl_last_done)) ? 0 : 0.75;
    drawfill(ang + Math.PI * 0.5 - d, seg.myFill.above, true);
    drawfill(ang - Math.PI * 0.5 + d, seg.myFill.below, true);
    if (bl_phase > 1 && !(bl_phase === 2 && bl_last_done)){
      drawfill(ang + Math.PI * 0.5 + d, seg.otherFill ? seg.otherFill.above : null, false);
      drawfill(ang - Math.PI * 0.5 - d, seg.otherFill ? seg.otherFill.below : null, false);
    }
  }
  if (bl_phase < 4){
    bl_oldsegs.forEach(function(seg){
      drawseg(seg, true, 1);
    });
    bl_segs.forEach(function(seg){
      drawseg(seg, false, 2);
      labels.push({
        txt: seg.id,
        x: (segStart(seg)[0] + segEnd(seg)[0]) / 2,
        y: (segStart(seg)[1] + segEnd(seg)[1]) / 2
      });
    });
  }
  var stw = 40;
  var sth = 20;
  function stpos(i){
    return [ stw * 1.5 + 20, cnvHeight / 2 - i * sth - 30 - sth / 2 ];
  }
  if (bl_phase < 4 && bl_last_check){
    ctx.beginPath();
    segPath(bl_last_check.seg1, ctx);
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    segPath(bl_last_check.seg2, ctx);
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    if (bl_last_check_i1 === false || bl_last_check_i2 === false){
      ctx.beginPath();
      var c1 = stpos(bl_last_temp_status_i);
      c1[0] += stw + 10;
      var c2 = stpos(bl_last_check_i1 === false ? bl_last_check_i2 : bl_last_check_i1);
      ctx.moveTo(c1[0], c1[1]);
      ctx.lineTo(c2[0], c2[1]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0f0';
      ctx.stroke();
    }
    else{
      ctx.beginPath();
      var c1 = stpos(bl_last_check_i1);
      var c2 = stpos(bl_last_check_i2);
      ctx.arc(c1[0] + stw / 2, (c2[1] + c1[1]) / 2,
        Math.abs(c2[1] - c1[1]) / 2, 0, Math.PI * 2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0f0';
      ctx.stroke();
    }
  }
  if (bl_phase < 4 && bl_last_div_seg){
    ctx.beginPath();
    ctx.arc(bl_last_div_seg.p[0], bl_last_div_seg.p[1], 6, 0, Math.PI * 2);
    ctx.fillStyle = '#aa0';
    ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  if (bl_phase < 4){
    for (var i = 0; i < bl_status.length; i++){
      var c = stpos(i);
      labels.push({
        txt: bl_status[i].id,
        x: c[0],
        y: c[1]
      });
      ctx.beginPath();
      ctx.rect(c[0] - stw / 2, c[1] - sth / 2, stw, sth);
      ctx.fillStyle = bl_last_status === bl_status[i].id ? '#ff6' : '#fff';
      ctx.fill();
      ctx.strokeStyle = bl_last_status === bl_status[i].id ? '#444' : '#aaa';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }
  if (bl_phase < 4 && bl_last_pop_seg){
    var c = stpos(bl_last_pop_seg_i);
    c[0] -= stw + 10;
    labels.push({
      txt: bl_last_pop_seg.seg.id,
      x: c[0],
      y: c[1]
    });
    ctx.beginPath();
    ctx.rect(c[0] - stw / 2, c[1] - sth / 2, stw, sth);
    ctx.fillStyle = '#eee';
    ctx.fill();
    ctx.strokeStyle = '#ddd'
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  if (bl_phase < 4 && bl_last_temp_status){
    var c = stpos(bl_last_temp_status_i);
    c[0] += stw + 10;
    labels.push({
      txt: bl_last_temp_status.seg.id,
      x: c[0],
      y: c[1]
    });
    ctx.beginPath();
    ctx.rect(c[0] - stw / 2, c[1] - sth / 2, stw, sth);
    ctx.fillStyle = '#dfd';
    ctx.fill();
    ctx.strokeStyle = '#cfc'
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  if (bl_phase < 4 && bl_last_chop){
    ctx.beginPath();
    segPath(bl_last_chop.seg, ctx);
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#f00';
    ctx.stroke();
  }
  if (bl_phase < 4 && bl_vert !== false){
    ctx.beginPath();
    ctx.moveTo(bl_vert, cnvHeight / 2);
    ctx.lineTo(bl_vert, 0);
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  if (bl_phase === 4){
    bl_selected.forEach(function(seg){
      ctx.beginPath();
      segPath(seg, ctx);
      ctx.strokeStyle = bl_last_done ? '#070' : '#e2e2e2';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(segStart(seg)[0], segStart(seg)[1], 3, 0, Math.PI * 2);
      ctx.fillStyle = bl_last_done ? '#070' : '#e2e2e2';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(segEnd(seg)[0], segEnd(seg)[1], 3, 0, Math.PI * 2);
      ctx.fillStyle = bl_last_done ? '#070' : '#e2e2e2';
      ctx.fill();
    });
  }
  if (bl_phase === 4 || (bl_phase === 5 && bl_last_done)){
    ctx.beginPath();
    bl_oldchains_c.forEach(function(segs){
      for (let i = 0; i < segs.length; i++) {
        segPath(segs[i], ctx, i !== 0);
      }
    });
    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
    ctx.fill('evenodd');
    ctx.strokeStyle = '#7f7';
    ctx.lineWidth = 1;
    ctx.stroke();
    function drawOldChains(bl_oldchains, bl_oldchainids, color) {
      bl_oldchains.forEach(function(ch, chi){
        var totx = 0;
        var toty = 0;
        for (var i = 0; i < ch.length; i++){
          var pt = segStart(ch[i]);
          totx += pt[0];
          toty += pt[1];
          ctx.beginPath();
          ctx.arc(pt[0], pt[1], 3, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        }
        labels.push({
          txt: bl_oldchainids_c[chi],
          x: totx / ch.length,
          y: toty / ch.length
        });
      });
    }
    drawOldChains(bl_oldchains_o, bl_oldchainids_o, '#777');
    drawOldChains(bl_oldchains_c, bl_oldchainids_c, '#7f7');

    function drawarrow(seg, rad){
      var pt1 = segStart(seg);
      var pt2 = segEnd(seg);
      var arrowLen = 8;
      var arrowAng = Math.PI - 0.45;
      ctx.beginPath();
      segPath(seg, ctx);

      const m1 = segPoint(seg, 0.9);
      const m2 = segPoint(seg, 1);
      var ang = Math.atan2(m2[1] - m1[1], m2[0] - m1[0]);
      var ax = pt2[0] - Math.cos(ang) * rad;
      var ay = pt2[1] - Math.sin(ang) * rad;
      ctx.moveTo(ax, ay);
      ctx.lineTo(
        ax + Math.cos(ang + arrowAng) * arrowLen,
        ay + Math.sin(ang + arrowAng) * arrowLen
      );
      ctx.moveTo(ax, ay);
      ctx.lineTo(
        ax + Math.cos(ang - arrowAng) * arrowLen,
        ay + Math.sin(ang - arrowAng) * arrowLen
      );
    }

    function drawChains(bl_chains, bl_chainids, color, fillFlagColor) {
      bl_chains.forEach(function(ch, chi){
        var rad = 3;
        for (var i = 0; i < ch.length; i++){
          const seg = ch[i].seg;
          var pt1 = segStart(seg);
          var pt2 = segEnd(seg);
          drawarrow(seg, rad);
          ctx.lineWidth = 1;
          ctx.strokeStyle = color;
          ctx.stroke();

          if (fillFlagColor) {
            const m1 = segPoint(seg, 0.49);
            const m2 = segPoint(seg, 0.51);
            var ang = Math.atan2(m2[1] - m1[1], m2[0] - m1[0]) + Math.PI / 2;
            const dist = ch[i].fill ? 6 : -6;
            ctx.beginPath();
            ctx.arc(
              dist * Math.cos(ang) + (m1[0] + m2[0]) / 2,
              dist * Math.sin(ang) + (m1[1] + m2[1]) / 2,
              3,
              0, Math.PI * 2
            );
            ctx.fillStyle = fillFlagColor;
            ctx.fill();
          }

          ctx.beginPath();
          ctx.arc(pt1[0], pt1[1], rad, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.beginPath();
          ctx.arc(pt2[0], pt2[1], rad, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();

          labels.push({
            txt: bl_chainids[chi],
            x: (pt1[0] + pt2[0]) / 2,
            y: (pt1[1] + pt2[1]) / 2
          });
        }
      });
    }
    drawChains(bl_chains_o, bl_chainids_o, '#777', false);
    drawChains(bl_chains_c, bl_chainids_c, '#070', '#060');

    if (bl_last_seg_keep){
      var pt1 = segStart(bl_last_seg_keep.sf.seg);
      var pt2 = segEnd(bl_last_seg_keep.sf.seg);
      const color = bl_last_seg_keep.closed ? '#0f0' : '#aaa';
      ctx.beginPath();
      drawarrow(bl_last_seg_keep.sf.seg, 3.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(pt1[0], pt1[1], 3.5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(pt2[0], pt2[1], 3.5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();

      if (bl_last_seg_keep_match !== false){
        labels.push({
          txt:
            bl_last_seg_keep_match.c
              ? bl_chainids_c[bl_last_seg_keep_match.i]
              : bl_chainids_o[bl_last_seg_keep_match.i],
          x: (pt1[0] + pt2[0]) / 2,
          y: (pt1[1] + pt2[1]) / 2
        });
      }
    }
  }

  // move labels around so that they don't overlap
  for (var i = 1; i < labels.length; i++){
    if (labels[i].txt === '')
      continue;
    for (var j = 0; j < i; j++){
      if (labels[j].txt === '')
        continue;
      var dx = labels[i].x - labels[j].x;
      var dy = labels[i].y - labels[j].y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 5){
        labels[j].txt += ', ' + labels[i].txt;
        labels[i].txt = '';
      }
      else if (dist < 16){
        labels[j].y -= 4;
        labels[i].y += 12;
      }
    }
  }


  let regions1, regions2;
  let inverted1 = false, inverted2 = false;
  let open1 = [], open2 = [];
  if ('poly1' in demo) {
    regions1 = demo.poly1.regions;
    inverted1 = demo.poly1.inverted;
    regions2 = demo.poly2.regions;
    inverted2 = demo.poly2.inverted;
  } else {
    regions1 = demo.shape1;
    regions2 = demo.shape2;
    open1 = demo.shape1Open || [];
    open2 = demo.shape2Open || [];
  }
  drawPolys([{
    regions: regions1,
    inverted: inverted1,
    open: open1,
    fill: 'rgba(255, 0, 0, 0.2)',
    stroke: '#f00',
    invertRect: [[0, 0], [cnvWidth, cnvHeight / 2]],
    offset: cnvHeight / 2
  }, {
    regions: regions2,
    inverted: inverted2,
    open: open2,
    fill: 'rgba(0, 0, 255, 0.2)',
    stroke: '#00f',
    invertRect: [[0, 0], [cnvWidth, cnvHeight / 2]],
    offset: cnvHeight / 2
  }]);

  // draw labels
  //*
  ctx.save();
  ctx.setTransform(rscale, 0, 0, rscale, 0, 0);
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  labels.forEach(function(lbl){
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fillText(lbl.txt, lbl.x +  1, cnvHeight - lbl.y +  1);
    ctx.fillText(lbl.txt, lbl.x +  1, cnvHeight - lbl.y +  0);
    ctx.fillText(lbl.txt, lbl.x +  1, cnvHeight - lbl.y + -1);
    ctx.fillText(lbl.txt, lbl.x +  0, cnvHeight - lbl.y +  1);
    ctx.fillText(lbl.txt, lbl.x +  0, cnvHeight - lbl.y + -1);
    ctx.fillText(lbl.txt, lbl.x + -1, cnvHeight - lbl.y +  1);
    ctx.fillText(lbl.txt, lbl.x + -1, cnvHeight - lbl.y +  0);
    ctx.fillText(lbl.txt, lbl.x + -1, cnvHeight - lbl.y + -1);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillText(lbl.txt, lbl.x, cnvHeight - lbl.y);
  });
  ctx.restore(); // */

  if (buildLogMax === 0){
    drawPolys([{
      regions: clipResult.result.regions,
      inverted: clipResult.result.inverted,
      open: clipResult.result.open || [],
      fill: 'rgba(0, 255, 0, 0.7)',
      stroke: '#070',
      invertRect: [[0, 0], [cnvWidth, cnvHeight / 2]],
      offset: 0
    }]);
  }

  ctx.save();
  ctx.setTransform(rscale, 0, 0, rscale, 0, 0);
  ctx.font = '13px sans-serif';
  ctx.fillStyle = '#000';
  ctx.fillText(mode, 4, cnvHeight / 2 + 16);
  ctx.fillText(caseName, 4, 16);
  ctx.restore();

  var phase = buildLogMax === 0 ? 'Result' :
    bl_phase === 0 ? 'Phase 1. Self-Intersect Red' :
    bl_phase === 1 ? (bl_last_done ? 'Phase 1 Result' : 'Phase 2. Self-Intersect Blue') :
    bl_phase === 2 ? (bl_last_done ? 'Phase 2 Result' : 'Phase 3. Red vs. Blue') :
    bl_phase === 3 ? 'Phase 3 Result' :
    bl_phase === 4 ? (bl_last_done ? 'Segment Selection' : 'Phase 4. Segment Chaining') :
    'Phase 4 Result';
  ctx.save();
  ctx.setTransform(rscale, 0, 0, rscale, 0, 0);
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillStyle = '#000';
  ctx.fillText(phase, cnvWidth - 4, cnvHeight / 2 + 16);
  ctx.restore();

  ctx.fillStyle = '#999';
  ctx.fillRect(0, 0, cnvWidth * buildLogMax / clipResult.build_log.length, 3);

  ctx.beginPath();
  for (var x = 0; x < cnvWidth; x += 10){
    ctx.moveTo(x, cnvHeight / 2);
    ctx.lineTo(x + 5, cnvHeight / 2);
  }
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // draw info log
  ctx.save();
  ctx.setTransform(rscale, 0, 0, rscale, 0, 0);
  ctx.font = '13px monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#000';
  for (let y = 210, i = 0; y >= 0 && i < bl_info.length; y -= 20, i++) {
    const { msg, data } = bl_info[i];
    ctx.fillText(msg + (
      typeof data === 'undefined'
      ? ''
      : ' ' + JSON.stringify(data)
    ), 10, y);
  }
  ctx.restore();
}

function init(){
  cnv = document.getElementById('cnv');
  ctx = cnv.getContext('2d');
  cnv.style.width = cnv.width / wscale + 'px';
  cnv.style.height = cnv.height / wscale + 'px';
  // make y go up and scale by 2 (for high DPI screens)
  ctx.transform(rscale, 0, 0, -rscale, 0, cnv.height);
  cnvWidth = cnv.width / rscale;
  cnvHeight = cnv.height / rscale;

  nextDemo(1);

  function mousePos(e){
    var rect = cnv.getBoundingClientRect();
    return [
      e.clientX - rect.left,
      cnvHeight - e.clientY + rect.top
    ];
  }

  function closestPoint(regions, x, y){
    x = unscaleX(x);
    y = unscaleY(y);
    var reg = false;
    var vert = false;
    var len2 = false;
    var j = false;
    regions.forEach(function(region){
      for (var i = 0; i < region.length; i++){
        const pt = region[i];
        for (var jj = 0; jj < pt.length; jj += 2) {
          var dx = scaleX(pt[jj] - x);
          var dy = scaleY(pt[jj + 1] - y);
          var thisLen2 = dx * dx + dy * dy;
          if (len2 === false || thisLen2 < len2){
            reg = region;
            vert = i;
            j = jj;
            len2 = thisLen2;
          }
        }
      }
    });
    return {
      region: reg,
      vert: vert,
      j: j,
      len: Math.sqrt(len2)
    };
  }

  function mouseTrackHover(mp){
    // look for the closest node
    let regions1, regions2;
    if ('poly1' in demo) {
      regions1 = demo.poly1.regions;
      regions2 = demo.poly2.regions;
    } else {
      regions1 = demo.shape1;
      regions2 = demo.shape2;
    }
    var p1 = closestPoint(regions1, mp[0], mp[1] - cnvHeight / 2);
    var p2 = closestPoint(regions2, mp[0], mp[1] - cnvHeight / 2);
    if (p2.len < p1.len)
      p1 = p2;
    if (p1.len > 10) {
      if (hover !== false) {
        hover = false;
        redraw();
      }
      return;
    }
    if (
      hover === false ||
      hover.region !== p1.region ||
      hover.vert !== p1.vert ||
      hover.j !== p1.j
    ) {
      hover = p1;
      redraw();
    }
  }

  var dragging = false;

  cnv.addEventListener('mousemove', function(e){
    var mp = mousePos(e);
    if (dragging){
      var dx = mp[0] - dragging[0];
      var dy = mp[1] - dragging[1];
      var pt = hover.region[hover.vert];
      const ix = hover.j;
      const iy = hover.j + 1;
      if (pt[iy] + dy < 0)
        dy = -pt[iy];
      if (document.getElementById('snap').checked){
        var tx = pt[ix] + dx;
        var ty = pt[iy] + dy;
        tx = Math.round(tx / 10) * 10;
        ty = Math.round(ty / 10) * 10;
        dx = tx - pt[ix];
        dy = ty - pt[iy];
      }
      if (dx !== 0 || dy !== 0){
        dragging = [dragging[0] + dx, dragging[1] + dy];
        pt[ix] = unscaleX(scaleX(pt[ix]) + dx);
        pt[iy] = unscaleY(scaleY(pt[iy]) + dy);
        recalc();
      }
    }
    else
      mouseTrackHover(mp);

    if (window.debugMousePos === true){
      ctx.save();
      var mx = mp[0], my = mp[1] - cnvHeight / 2;
      if (hover !== false){
        mx = hover.region[hover.vert][hover.j];
        my = hover.region[hover.vert][hover.j + 1];
      }
      ctx.setTransform(rscale, 0, 0, rscale, 0, 0);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, 100, 20);
      ctx.fillStyle = '#000';
      ctx.textAlign = 'left'
      ctx.textBaseline = 'top';
      ctx.fillText('(' + mx + ', ' + my + ')', 0, 0);
      ctx.restore();
    }
  });

  cnv.addEventListener('mouseup', function(e){
    var mp = mousePos(e);
    if (dragging){
      dragging = false;
      mouseTrackHover(mp);
      redraw();
    }
    else
      mouseTrackHover(mp);
  });

  cnv.addEventListener('mouseleave', function(e){
    if (dragging){
      dragging = false;
      hover = false;
      redraw();
    }
  });

  cnv.addEventListener('mousedown', function(e){
    var mp = mousePos(e);
    mouseTrackHover(mp);
    if (hover !== false){
      dragging = mp; // begin dragging
      e.preventDefault();
    }
  });

  document.addEventListener('keydown', function(e){
    if (e.keyCode === 37){ // left
      buildLogNextWrap(e.shiftKey ? -10 : -1);
      e.preventDefault();
    }
    else if (e.keyCode === 39){ // right
      buildLogNextWrap(e.shiftKey ? 10 : 1);
      e.preventDefault();
    }
    else if (e.keyCode === 32){ // space
      buildLogPlay();
      e.preventDefault();
    }
  });
}

window.demo = demo;
window.init = init;
window.recalc = recalc;
window.setMode = setMode;
window.nextDemo = nextDemo;
window.buildLogNextWrap = buildLogNextWrap;
window.buildLogPlay = buildLogPlay;
  </script>
  <p>
    <canvas id="cnv" width="1400" height="1000"></canvas>
  </p>
  <p>
    Drag the polygon nodes to change the shape.  Click the buttons below and have fun!
  </p>
  <p>
    Operation:
    <button onclick="javascript: setMode('Intersect');">Intersect</button>
    <button onclick="javascript: setMode('Union');">Union</button>
    <button onclick="javascript: setMode('Red - Blue');">Red - Blue</button>
    <button onclick="javascript: setMode('Blue - Red');">Blue - Red</button>
    <button onclick="javascript: setMode('Xor');">Xor</button>
  </p>
  <p>
    <input type="checkbox" id="snap" checked="checked" /><label for="snap"> Snap</label>
    <button style="margin-left: 1em;" onclick="javascript: poly1.inverted = !poly1.inverted; recalc();">Invert Red</button>
    <button onclick="javascript: poly2.inverted = !poly2.inverted; recalc();">Invert Blue</button>
    <span style="margin-left: 1em;">Animation:</span>
    <button onclick="javascript: buildLogNextWrap(-1);">Prev</button>
    <button onclick="javascript: buildLogPlay();" id="bl_play">Play</button>
    <button onclick="javascript: buildLogNextWrap(1);">Next</button>
    <span style="margin-left: 1em;">Demo:</span>
    <button onclick="javascript: nextDemo(-1);">Prev</button>
    <button onclick="javascript: nextDemo(1);">Next</button>
  </p>
  <p>
    Polygon Clipping Demo based somewhat on the F. Martinez et al. algorithm (2008)
  </p>
  <p>
    Coded (painfully) by
    <a href="https://github.com/velipso">@velipso</a> from
    <a href="https://sean.fun/">sean.fun</a> &ndash; 0BSD License
  </p>
  <p>
    <a href="https://sean.fun/a/polygon-clipping-pt2">Read the companion tutorial</a>
    <span style="padding: 0 1em; opacity: 0.3;">|</span>
    <a href="https://github.com/velipso/polybool">Project home on GitHub</a>
  </p>
</body>
</html>
